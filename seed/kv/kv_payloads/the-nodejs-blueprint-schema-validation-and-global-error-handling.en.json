{
  "attributes": {
    "type": "post",
    "title": "The Node.js Blueprint: Schema Validation and Global Error Handling",
    "description": "Standardize your API integrity by implementing Zod for type-safe validation and a centralized error-handling middleware.",
    "tags": [
      "Nodejs",
      "TypeScript",
      "Express",
      "Backend",
      "Zod",
      "Error Handling"
    ],
    "publishedAt": "2025-12-27",
    "repository": "https://github.com/poschuler/nodejs-blueprint/tree/feature/validation-error-handling"
  },
  "html": "<blockquote>\n<p><strong>Note:</strong> This post continues from the previous setup. You can find the starting point in the <a href=\"https://github.com/poschuler/nodejs-blueprint/tree/initial-project-setup\"><code>initial-setup</code></a> branch of the repository.</p>\n</blockquote>\n<p>When building an API, manual input validation often results in a mess of <code>if</code> statements and inconsistent error responses. A cleaner approach is to use Zod for schema enforcement and a Global Middleware to catch exceptions.</p>\n<p>This approach allows us to:</p>\n<ul>\n<li><p>Ensure data integrity before business logic executes.</p>\n</li>\n<li><p>Standardize API error responses across the entire project.</p>\n</li>\n<li><p>Remove repetitive <code>try-catch</code> boilerplate from controllers.</p>\n</li>\n</ul>\n<h2>Installing Zod</h2>\n<p>We use Zod for schema declaration and validation. It provides excellent TypeScript inference, removing the need to maintain separate interfaces for our request payloads.</p>\n<pre><code class=\"language-bash\">npm install zod\n</code></pre>\n<h2>Defining the Exception Schema</h2>\n<p>We start by defining the <code>ValidationError</code> and <code>ValidationException</code>. This allows us to distinguish between routine validation input failure and critical system crash.</p>\n<p><strong><code>./src/exceptions/validation-error.ts</code></strong></p>\n<pre><code class=\"language-typescript\">export interface ValidationError {\n  code: string;\n  property: string;\n  message: string;\n}\n</code></pre>\n<p><strong><code>./src/exceptions/validation-exception.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { ValidationError } from &quot;./validation-error&quot;;\n\nexport class ValidationException extends Error {\n  public readonly errors: ValidationError[];\n\n  constructor(errors: ValidationError[]) {\n    super(&quot;Validation failed&quot;);\n    this.errors = errors;\n    Object.setPrototypeOf(this, ValidationException.prototype);\n  }\n}\n</code></pre>\n<h2>Global Exception Middleware</h2>\n<p>This middleware acts as the final boundary of the application. It catches any thrown exceptions and formats them into a consistent JSON structure.</p>\n<p><strong><code>./src/middlewares/exception-handler.middleware.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { Request, Response, NextFunction } from &quot;express&quot;;\nimport { ValidationException } from &quot;../exceptions/validation-exception&quot;;\n\nexport class ExceptionHandlerMiddleware {\n  public handle = (\n    err: Error,\n    _req: Request,\n    res: Response,\n    _next: NextFunction,\n  ) =&gt; {\n    if (err instanceof ValidationException) {\n      return res.status(400).json({\n        code: &quot;VALIDATION_ERROR&quot;,\n        message: err.message,\n        errors: err.errors,\n      });\n    }\n\n    // For all other errors, we&#39;ll return a generic 500 response.\n    return res.status(500).json({\n      message: &quot;Internal Server Error&quot;,\n    });\n  };\n}\n</code></pre>\n<h2>The Validation Utility</h2>\n<p>To avoid repeating validation logic, we use a shared helper that acts as a bridge between Zod and our custom exceptions. This ensures that if validation passes, the returned data is fully typed.</p>\n<p><strong><code>./src/shared/validations/validate-request-with-schema.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { ZodType } from &quot;zod&quot;;\nimport type { Request } from &quot;express&quot;;\nimport { ValidationException } from &quot;../../exceptions/validation-exception&quot;;\n\nexport const validateRequestWithSchema = &lt;T&gt;(\n  schema: ZodType&lt;T&gt;,\n  req: Request,\n): T =&gt; {\n  const result = schema.safeParse({\n    query: req.query ?? {},\n    body: req.body ?? {},\n    params: req.params ?? {},\n  });\n\n  if (!result.success) {\n    const errors = result.error.issues.map((e) =&gt; ({\n      code: e.code,\n      property: e.path.join(&quot;.&quot;) || &quot;unknown&quot;,\n      message: e.message,\n    }));\n    throw new ValidationException(errors);\n  }\n\n  return result.data;\n};\n</code></pre>\n<h2>Refactoring for Validation</h2>\n<p>We now move from our initial mock methods to a validated implementation. The schema is defined close to the feature, and the controller is updated to use our &quot;gatekeeper&quot; utility.</p>\n<p><strong><code>./src/features/products/schemas/create-products.schema.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import z from &quot;zod&quot;;\n\nexport const createProductSchema = z.object({\n  body: z.object({\n    name: z.string().min(3).max(100),\n    description: z.string().min(10).max(500),\n    price: z.number().min(0),\n  }),\n});\n</code></pre>\n<h3>Updating the Controller</h3>\n<p>We refactor the previous <code>addProduct</code> into <code>createProduct</code>. Notice how the logic focuses purely on the &quot;happy path&quot; because failures are handled globally.</p>\n<p><strong><code>./src/features/products/products-controller.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { Request, Response } from &quot;express&quot;;\nimport { validateRequestWithSchema } from &quot;../../shared/validations/validate-request-with-schema&quot;;\nimport { createProductSchema } from &quot;./schemas/create-products.schema&quot;;\n\ntype Product = {\n  id: number;\n  name: string;\n  description: string;\n  price: number;\n};\n\nconst products: Product[] = [\n  {\n    id: 1,\n    name: &quot;Laptop&quot;,\n    description: &quot;A high-performance laptop&quot;,\n    price: 1200.0,\n  },\n  {\n    id: 2,\n    name: &quot;Smartphone&quot;,\n    description: &quot;A feature-rich smartphone&quot;,\n    price: 800.0,\n  },\n];\n\nexport class ProductsController {\n  public getProducts = async (_: Request, res: Response) =&gt; {\n    res.status(200).json(products);\n  };\n\n  // Refactored from addProduct\n  public createProduct = async (req: Request, res: Response) =&gt; {\n    const validatedData = validateRequestWithSchema(createProductSchema, req);\n\n    const newProduct: Product = {\n      id: products.length + 1,\n      name: validatedData.body.name,\n      description: validatedData.body.description,\n      price: validatedData.body.price,\n    };\n\n    products.push(newProduct);\n\n    res.status(201).json(newProduct);\n  };\n}\n</code></pre>\n<p>By the time the code reaches newProduct, the data is guaranteed to be clean and correctly typed.</p>\n<h3>Finalizing the Routes</h3>\n<p>We update the <code>products-routes.ts</code> changing the <code>addProduct</code> method to <code>createProduct</code>.</p>\n<p><strong><code>./src/features/products/products-routes.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { Router } from &quot;express&quot;;\nimport { ProductsController } from &quot;./products-controller&quot;;\n\nexport const productsRoutes = (): Router =&gt; {\n  const router = Router();\n  const controller = new ProductsController();\n\n  router.get(&quot;/&quot;, controller.getProducts);\n  router.post(&quot;/&quot;, controller.createProduct); // Refactored from addProduct\n\n  return router;\n};\n</code></pre>\n<p>Finally, we update our routes to reflect the new controller method and register the <code>ExceptionHandlerMiddleware</code>. The exception handler must be the last middleware registered to ensure it catches exceptions bubbling up from the routes.</p>\n<p><strong><code>./src/routes.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { Router, type Request, type Response } from &quot;express&quot;;\nimport { productsRoutes } from &quot;./features/products/products-routes&quot;;\nimport { ExceptionHandlerMiddleware } from &quot;./middlewares/exception-handler.middleware&quot;;\n\nexport const appRoutes = (): Router =&gt; {\n  const router = Router();\n  const exceptionHandlerMiddleware = new ExceptionHandlerMiddleware();\n\n  router.use(&quot;/api/products&quot;, productsRoutes());\n\n  router.get(&quot;/health&quot;, (_: Request, res: Response) =&gt; {\n    res.json({\n      status: &quot;up&quot;,\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n    });\n  });\n\n  // The exception handler must be the last middleware to be registered.\n  router.use(exceptionHandlerMiddleware.handle);\n\n  return router;\n};\n</code></pre>\n<h2>Verifying the Implementation</h2>\n<p>By intentionally sending malformed data to <code>POST /api/products</code>, we verify that the gatekeeper and global handler are in sync. Instead of a crashed process, the API responds with an actionable <code>400 Bad Request</code>.</p>\n<p><code>POST /api/products</code></p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;A&quot;,\n  &quot;description&quot;: &quot;Short&quot;,\n  &quot;price&quot;: -10\n}\n</code></pre>\n<p><code>API Response</code></p>\n<pre><code class=\"language-json\">{\n  &quot;code&quot;: &quot;VALIDATION_ERROR&quot;,\n  &quot;message&quot;: &quot;Validation failed&quot;,\n  &quot;errors&quot;: [\n    {\n      &quot;code&quot;: &quot;too_small&quot;,\n      &quot;property&quot;: &quot;body.name&quot;,\n      &quot;message&quot;: &quot;String must contain at least 3 character(s)&quot;\n    },\n    {\n      &quot;code&quot;: &quot;too_small&quot;,\n      &quot;property&quot;: &quot;body.description&quot;,\n      &quot;message&quot;: &quot;String must contain at least 10 character(s)&quot;\n    },\n    {\n      &quot;code&quot;: &quot;too_small&quot;,\n      &quot;property&quot;: &quot;body.price&quot;,\n      &quot;message&quot;: &quot;Number must be greater than or equal to 0&quot;\n    }\n  ]\n}\n</code></pre>\n<h2>Conclusion</h2>\n<p>By offloading validation to Zod and centralizing failure management, we&#39;ve achieved three architectural goals:</p>\n<ul>\n<li><p><strong>Clean Logic</strong>: Controllers focus on the &quot;happy path.&quot;</p>\n</li>\n<li><p><strong>Predictability</strong>: The client receives consistent, structured errors.</p>\n</li>\n<li><p><strong>Type Safety</strong>: Runtime data and TypeScript types stay in sync.</p>\n</li>\n</ul>\n<p>While the input is now secure, our controller is still directly managing an in-memory array. This creates a tight coupling between our business logic and our data storage.</p>\n<p>The next step is implement the Repository Pattern. We&#39;ll move our data management logic behind a clean interface, allowing us to swap our in-memory storage for a persistent database without modifying the controller.</p>\n"
}