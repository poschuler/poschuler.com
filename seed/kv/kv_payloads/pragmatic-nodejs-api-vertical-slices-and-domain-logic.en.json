{
  "attributes": {
    "type": "post",
    "title": "Pragmatic Node.js API #3: Vertical Slices Architecture and Domain Logic",
    "description": "Organize your Node.js API using Vertical Slices to encapsulate features and maintain a clear separation of concerns, enhancing maintainability and scalability.",
    "tags": [
      "Nodejs",
      "TypeScript",
      "Express",
      "Backend",
      "Vertical Slices",
      "Software Architecture"
    ],
    "publishedAt": "2026-02-20",
    "repository": "https://github.com/poschuler/pragmatic-nodejs-api/tree/feature/vertical-slices-and-domain-logic"
  },
  "html": "<p>This post introduces Vertical Slices Architecture and a proper Domain Layer. Instead of grouping code by technical role, we organize by feature. Each endpoint becomes a self-contained slice with its own handler, DTOs, mapper, and schema. Business rules move into a Domain Entity, and a Service layer manages the data.</p>\n<p>This approach allows us to:</p>\n<ul>\n<li><p>Encapsulate each endpoint as a self-contained, navigable unit.</p>\n</li>\n<li><p>Separate domain logic from HTTP and infrastructure concerns.</p>\n</li>\n<li><p>Control the shape of API input and output through explicit DTOs and Mappers.</p>\n</li>\n<li><p>Scale the codebase horizontally by adding new slices without modifying existing ones.</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>Code &amp; Resources:</strong></p>\n<ul>\n<li><strong>Starting Point:</strong> Use the <a href=\"https://github.com/poschuler/pragmatic-nodejs-api/tree/feature/validation-error-handling\"><code>feature/validation-error-handling</code></a> branch.</li>\n<li><strong>Final Implementation:</strong> Find the complete code for this part in the <a href=\"https://github.com/poschuler/pragmatic-nodejs-api/tree/feature/vertical-slices-and-domain-logic\"><code>feature/vertical-slices-and-domain-logic</code></a> branch.</li>\n</ul>\n</blockquote>\n<h2>Understanding Vertical Slices</h2>\n<p>In a traditional Layered Architecture, code is grouped by technical role: controllers in one folder, services in another, schemas in a third. This creates an implicit coupling — a single feature change often requires touching files scattered across the entire project tree.</p>\n<p>Vertical Slices take the opposite approach. Each endpoint is a self-contained folder that owns its handler, DTOs (Request/Response), mapper, and validation schema. The boundaries are drawn around <strong>what the application does</strong>, not around the technical role of the code.</p>\n<p>Here&#39;s our evolved project structure:</p>\n<pre><code>src/\n├── app.ts\n├── server.ts\n├── routes.ts\n│\n├── config/\n│   └── config.ts\n│\n├── domain/\n│   └── product.entity.ts\n│\n├── exceptions/\n│   ├── validation-error.ts\n│   └── validation-exception.ts\n│\n├── middlewares/\n│   └── exception-handler.middleware.ts\n│\n├── shared/\n│   └── validations/\n│       └── validate-request-with-schema.ts\n│\n└── features/\n    └── products/\n        ├── products.routes.ts\n        ├── products.service.ts\n        │\n        ├── create-product/\n        │   ├── create-product.endpoint.ts\n        │   ├── create-product.mapper.ts\n        │   ├── create-product.request.ts\n        │   ├── create-product.response.ts\n        │   └── create-products.schema.ts\n        │\n        └── get-products/\n            ├── get-products.endpoint.ts\n            ├── get-products.mapper.ts\n            └── get-products.response.ts\n</code></pre>\n<p>Each endpoint under <code>features/products/</code> is its own vertical slice. The <code>create-product/</code> folder contains everything needed to handle a POST request: the endpoint handler, the input DTO, the output DTO, the mapper, and the validation schema. The <code>get-products/</code> folder does the same for GET. Nothing leaks between slices.</p>\n<h2>The Domain Entity</h2>\n<p>The Domain Entity is the core of the architecture. It represents the business concept with its rules and invariants, independent of any framework or HTTP concern.</p>\n<p>We create a <code>Product</code> class with a private constructor and a static <code>create()</code> factory. This pattern ensures that every <code>Product</code> instance is valid by construction — the factory enforces business rules before the object exists. The ID is generated internally, keeping identity management within the domain boundary.</p>\n<p><strong><code>./src/domain/product.entity.ts</code></strong></p>\n<pre><code class=\"language-typescript\">type CreateProductProps = {\n  name: string;\n  description: string;\n  price: number;\n};\n\nexport class Product {\n  private constructor(\n    public readonly id: number,\n    public readonly name: string,\n    public readonly description: string,\n    public readonly price: number,\n  ) {}\n\n  public static create(props: CreateProductProps): Product {\n    if (!props.name) {\n      throw new Error(&quot;Product name is required&quot;);\n    }\n\n    if (!props.description) {\n      throw new Error(&quot;Product description is required&quot;);\n    }\n\n    if (props.price &lt;= 0) {\n      throw new Error(&quot;Product price must be greater than zero&quot;);\n    }\n\n    // ID generation simulation\n    const id = Math.floor(Math.random() * 1000);\n\n    return new Product(id, props.name, props.description, props.price);\n  }\n}\n</code></pre>\n<p>Two things to note:</p>\n<ul>\n<li><p><strong>Domain Validation</strong>: The <code>create()</code> method enforces invariants like &quot;price must be greater than zero&quot;. These are business rules, distinct from the Zod schema validation that guards the HTTP boundary.</p>\n</li>\n<li><p><strong>ID Generation</strong>: The factory generates the ID internally. The caller provides only the business properties; identity is the domain&#39;s responsibility.</p>\n</li>\n</ul>\n<h2>The Service Layer</h2>\n<p>The service manages the collection of products and coordinates between the endpoint handlers and the domain. It holds the in-memory data and exposes the use cases of the feature.</p>\n<p><strong><code>./src/features/products/products.service.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { Product } from &quot;../../domain/product.entity&quot;;\nimport type { CreateProductRequest } from &quot;./create-product/create-product.request&quot;;\n\nexport class ProductsService {\n  private products: Product[] = [\n    Product.create({\n      name: &quot;Laptop&quot;,\n      description: &quot;A high-performance laptop&quot;,\n      price: 1200.0,\n    }),\n    Product.create({\n      name: &quot;Smartphone&quot;,\n      description: &quot;A feature-rich smartphone&quot;,\n      price: 800.0,\n    }),\n  ];\n\n  public getAllProducts(): Product[] {\n    return this.products;\n  }\n\n  public createProduct(product: CreateProductRequest): Product {\n    const newProduct = Product.create({\n      name: product.name,\n      description: product.description,\n      price: product.price,\n    });\n\n    this.products.push(newProduct);\n    return newProduct;\n  }\n}\n</code></pre>\n<p>The seed data flows through <code>Product.create()</code>, meaning even our initial data respects the domain&#39;s validation rules. The <code>createProduct</code> method receives a typed <code>CreateProductRequest</code> DTO and delegates construction to the domain factory. If <code>Product.create()</code> throws due to an invalid business rule, the product is never stored.</p>\n<h2>The DTO and Mapper Pattern</h2>\n<p>A key part of the Vertical Slices approach is controlling the shape of data at each boundary. Instead of directly exposing the domain entity in API responses, we use <strong>DTOs</strong> (Data Transfer Objects) to define exactly what the client sees, and <strong>Mappers</strong> to handle the conversion.</p>\n<h3>Get Products Slice</h3>\n<p>The <code>get-products/</code> slice defines a Response DTO and a Mapper that converts a domain <code>Product</code> into the response shape.</p>\n<p><strong><code>./src/features/products/get-products/get-products.response.ts</code></strong></p>\n<pre><code class=\"language-typescript\">export class GetProductsResponse {\n  constructor(\n    public readonly id: number,\n    public readonly name: string,\n    public readonly description: string,\n    public readonly price: number,\n  ) {}\n}\n</code></pre>\n<p><strong><code>./src/features/products/get-products/get-products.mapper.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { Product } from &quot;../../../domain/product.entity&quot;;\nimport { GetProductsResponse } from &quot;./get-products.response&quot;;\n\nexport class GetProductsMapper {\n  public static toResponse(product: Product): GetProductsResponse {\n    const { id, name, description, price } = product;\n    return new GetProductsResponse(id, name, description, price);\n  }\n}\n</code></pre>\n<p><strong><code>./src/features/products/get-products/get-products.endpoint.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { Request, Response } from &quot;express&quot;;\nimport type { ProductsService } from &quot;../products.service&quot;;\nimport { GetProductsMapper } from &quot;./get-products.mapper&quot;;\n\nexport const getProducts =\n  (service: ProductsService) =&gt; (_: Request, res: Response) =&gt; {\n    const products = service.getAllProducts();\n\n    const response = products.map((p) =&gt; GetProductsMapper.toResponse(p));\n\n    res.status(200).json(response);\n  };\n</code></pre>\n<p>The endpoint is a higher-order function — it receives the service and returns the actual request handler. This pattern eliminates the need for a controller class while keeping the service injectable. The mapper converts each domain <code>Product</code> into a <code>GetProductsResponse</code>, ensuring the API response shape is explicitly controlled.</p>\n<h3>Create Product Slice</h3>\n<p>The <code>create-product/</code> slice is richer — it includes a Request DTO, a Response DTO, a Mapper, the Zod schema, and the endpoint handler.</p>\n<p><strong><code>./src/features/products/create-product/create-product.request.ts</code></strong></p>\n<pre><code class=\"language-typescript\">export class CreateProductRequest {\n  constructor(\n    public readonly name: string,\n    public readonly description: string,\n    public readonly price: number,\n  ) {}\n}\n</code></pre>\n<p><strong><code>./src/features/products/create-product/create-product.response.ts</code></strong></p>\n<pre><code class=\"language-typescript\">export class CreateProductResponse {\n  constructor(\n    public readonly id: number,\n    public readonly name: string,\n    public readonly description: string,\n    public readonly price: number,\n  ) {}\n}\n</code></pre>\n<p><strong><code>./src/features/products/create-product/create-products.schema.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import z from &quot;zod&quot;;\n\nexport const createProductSchema = z.object({\n  body: z.object({\n    name: z.string().min(3).max(100),\n    description: z.string().min(10).max(500),\n    price: z.number().gt(0),\n  }),\n});\n</code></pre>\n<p><strong><code>./src/features/products/create-product/create-product.mapper.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { Product } from &quot;../../../domain/product.entity&quot;;\nimport { CreateProductResponse } from &quot;./create-product.response&quot;;\n\nexport class CreateProductMapper {\n  public static toResponse(product: Product): CreateProductResponse {\n    const { id, name, description, price } = product;\n    return new CreateProductResponse(id, name, description, price);\n  }\n}\n</code></pre>\n<p><strong><code>./src/features/products/create-product/create-product.endpoint.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { Request, Response } from &quot;express&quot;;\nimport { validateRequestWithSchema } from &quot;../../../shared/validations/validate-request-with-schema&quot;;\nimport { createProductSchema } from &quot;./create-products.schema&quot;;\nimport { CreateProductRequest } from &quot;./create-product.request&quot;;\nimport type { ProductsService } from &quot;../products.service&quot;;\nimport { CreateProductMapper } from &quot;./create-product.mapper&quot;;\n\nexport const createProduct =\n  (service: ProductsService) =&gt; (req: Request, res: Response) =&gt; {\n    const validateResult = validateRequestWithSchema(\n      createProductSchema,\n      req,\n    );\n\n    const createProductRequest = new CreateProductRequest(\n      validateResult.body.name,\n      validateResult.body.description,\n      validateResult.body.price,\n    );\n\n    const newProduct = service.createProduct(createProductRequest);\n\n    const response = CreateProductMapper.toResponse(newProduct);\n\n    res.status(201).json(response);\n  };\n</code></pre>\n<p>Notice the flow: the endpoint first validates the raw request using Zod (from the previous part), then maps the validated data into a typed <code>CreateProductRequest</code> DTO, passes it to the service, and finally maps the returned domain entity into a <code>CreateProductResponse</code>. Each step has a clear responsibility.</p>\n<h2>Wiring the Vertical Slice</h2>\n<p>The routes file becomes the composition root of the feature. It instantiates the service and wires each endpoint handler.</p>\n<p><strong><code>./src/features/products/products.routes.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { Router } from &quot;express&quot;;\nimport { ProductsService } from &quot;./products.service&quot;;\nimport { getProducts } from &quot;./get-products/get-products.endpoint&quot;;\nimport { createProduct } from &quot;./create-product/create-product.endpoint&quot;;\n\nexport const productsRoutes = (): Router =&gt; {\n  const router = Router();\n\n  const productService = new ProductsService();\n\n  router.get(&quot;/&quot;, getProducts(productService));\n  router.post(&quot;/&quot;, createProduct(productService));\n\n  return router;\n};\n</code></pre>\n<p>The service is created once and injected into each endpoint handler. Adding a new endpoint means creating a new slice folder and adding one line to this file.</p>\n<p>The main application routes file registers the feature routes and the global exception handler:</p>\n<p><strong><code>./src/routes.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { Router, type Request, type Response } from &quot;express&quot;;\nimport { productsRoutes } from &quot;./features/products/products.routes&quot;;\nimport { ExceptionHandlerMiddleware } from &quot;./middlewares/exception-handler.middleware&quot;;\n\nexport const appRoutes = (): Router =&gt; {\n  const router = Router();\n\n  const exceptionHandlerMiddleware = new ExceptionHandlerMiddleware();\n\n  router.use(&quot;/api/products&quot;, productsRoutes());\n\n  router.get(&quot;/health&quot;, (_: Request, res: Response) =&gt; {\n    res.json({\n      status: &quot;up&quot;,\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n    });\n  });\n\n  // The exception handler must be the last middleware to be registered.\n  router.use(exceptionHandlerMiddleware.handle);\n\n  return router;\n};\n</code></pre>\n<h2>Verifying the Implementation</h2>\n<p>Start the development server:</p>\n<pre><code class=\"language-bash\">npm run dev\n</code></pre>\n<p>Test the two endpoints to verify the full slices are working:</p>\n<p><strong>GET all products</strong> — <code>GET http://localhost:3000/api/products</code></p>\n<pre><code class=\"language-json\">[\n  {\n    &quot;id&quot;: 198,\n    &quot;name&quot;: &quot;Laptop&quot;,\n    &quot;description&quot;: &quot;A high-performance laptop&quot;,\n    &quot;price&quot;: 1200\n  },\n  {\n    &quot;id&quot;: 472,\n    &quot;name&quot;: &quot;Smartphone&quot;,\n    &quot;description&quot;: &quot;A feature-rich smartphone&quot;,\n    &quot;price&quot;: 800\n  }\n]\n</code></pre>\n<p><strong>Create a product</strong> — <code>POST http://localhost:3000/api/products</code></p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;Product 1&quot;,\n  &quot;description&quot;: &quot;Description of Product 1&quot;,\n  &quot;price&quot;: 9.99\n}\n</code></pre>\n<p><code>API Response</code></p>\n<pre><code class=\"language-json\">{\n  &quot;id&quot;: 731,\n  &quot;name&quot;: &quot;Product 1&quot;,\n  &quot;description&quot;: &quot;Description of Product 1&quot;,\n  &quot;price&quot;: 9.99\n}\n</code></pre>\n<p>The IDs are randomly generated by the domain entity, so they will differ on each run.</p>\n<p>Sending malformed data still returns a structured <code>400 Bad Request</code> thanks to the Zod validation and global exception handler from the previous part:</p>\n<p><code>POST /api/products</code></p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;A&quot;,\n  &quot;description&quot;: &quot;Short&quot;,\n  &quot;price&quot;: -10\n}\n</code></pre>\n<p><code>API Response</code></p>\n<pre><code class=\"language-json\">{\n  &quot;code&quot;: &quot;VALIDATION_ERROR&quot;,\n  &quot;message&quot;: &quot;Validation failed&quot;,\n  &quot;errors&quot;: [\n    {\n      &quot;code&quot;: &quot;too_small&quot;,\n      &quot;property&quot;: &quot;body.name&quot;,\n      &quot;message&quot;: &quot;String must contain at least 3 character(s)&quot;\n    },\n    {\n      &quot;code&quot;: &quot;too_small&quot;,\n      &quot;property&quot;: &quot;body.description&quot;,\n      &quot;message&quot;: &quot;String must contain at least 10 character(s)&quot;\n    },\n    {\n      &quot;code&quot;: &quot;too_small&quot;,\n      &quot;property&quot;: &quot;body.price&quot;,\n      &quot;message&quot;: &quot;Number must be greater than 0&quot;\n    }\n  ]\n}\n</code></pre>\n<h2>Conclusion</h2>\n<p>By introducing Vertical Slices and a proper Domain Entity, we&#39;ve achieved three key architectural improvements:</p>\n<ul>\n<li><p><strong>Endpoint Encapsulation</strong>: Each endpoint is a self-contained slice with its own handler, DTOs, mapper, and schema. Adding a new endpoint means adding a new folder, not scattering files across the project.</p>\n</li>\n<li><p><strong>Explicit API Boundaries</strong>: Request and Response DTOs give us full control over the shape of data entering and leaving the API, decoupled from the domain model.</p>\n</li>\n<li><p><strong>Domain Integrity</strong>: The <code>Product</code> entity enforces business invariants through its factory method. No invalid product can exist in the system, regardless of how it&#39;s created.</p>\n</li>\n</ul>\n"
}