{
  "attributes": {
    "type": "post",
    "title": "Pragmatic Node.js API #1: Setup Node.js, Express & TypeScript Project in 2026",
    "description": "The definitive starting point for your next project. Learn to setup Node.js, Express, and TypeScript using a professional, class-based architecture designed for long-term maintainability and scale.",
    "tags": [
      "Nodejs",
      "TypeScript",
      "Express",
      "Backend"
    ],
    "publishedAt": "2025-12-25",
    "repository": "https://github.com/poschuler/pragmatic-nodejs-api/tree/feature/initial-project-setup"
  },
  "html": "<p>Starting a new Node.js project from scratch can be surprisingly confusing. With so many choices for packages and folder structures, it’s easy to feel overwhelmed before you&#39;ve even written a line of code.</p>\n<p>I wrote this post to simplify that process for 2026. It&#39;s a practical starting point designed to help others get it right from day one, while serving as a reliable reference for whenever I need to bootstrap my own projects quickly.</p>\n<blockquote>\n<p><strong>Code &amp; Resources:</strong> The complete source code for this post is available on GitHub. You can find it in the <a href=\"https://github.com/poschuler/pragmatic-nodejs-api/tree/feature/initial-project-setup\"><code>feature/initial-project-setup</code></a> branch of the repository.</p>\n</blockquote>\n<h2>Prerequisites</h2>\n<p>Ensure Node.js v24+ is installed. Verify your environment:</p>\n<pre><code class=\"language-bash\">node --version\n</code></pre>\n<p>This guide is based on Node.js v24, but it should be compatible with other recent versions with minimal adjustments.</p>\n<h2>Step 1: Initialization and Dependencies</h2>\n<p>Initialize the project and install the core stack.</p>\n<pre><code class=\"language-bash\">mkdir nodejs-blueprint &amp;&amp; cd nodejs-blueprint\nnpm init -y\n\n# Tooling &amp; Types\nnpm install -D typescript @types/node @types/express @tsconfig/node24 tsx rimraf \n\n# Lint and Format, we install a exact version as Biome documentations recommends\nnpm install -D -E @biomejs/biome\n\n# Core Stack\nnpm install express dotenv\n</code></pre>\n<ul>\n<li><p><code>tsx</code>: Modern TypeScript execution for development with hot-reloading.</p>\n</li>\n<li><p><code>@tsconfig/node24</code>: A strict baseline for modern Node environments.</p>\n</li>\n<li><p><code>Biome</code>: High-performance unified tool for linting and formatting.</p>\n</li>\n</ul>\n<h2>Step 2: Configuration</h2>\n<p>First, let&#39;s initialize the default configuration files:</p>\n<pre><code class=\"language-bash\">npx tsc --init\nnpx @biomejs/biome init\n</code></pre>\n<p>Now, we use a modern <code>extends</code> approach for TypeScript and a centralized Biome configuration to enforce code quality.</p>\n<p><strong><code>tsconfig.json</code></strong></p>\n<pre><code class=\"language-json\">{\n  &quot;extends&quot;: &quot;@tsconfig/node24/tsconfig.json&quot;,\n  &quot;compilerOptions&quot;: {\n    &quot;outDir&quot;: &quot;./dist&quot;,\n    &quot;rootDir&quot;: &quot;./src&quot;\n  },\n  &quot;includes&quot;: [\n    &quot;src/**/*.js&quot;,\n    &quot;src/**/*.json&quot;,\n    &quot;src/**/*.ts&quot;,\n  ],\n  &quot;exclude&quot;: [\n    &quot;dist&quot;,\n    &quot;node_modules&quot;,\n  ]\n}\n</code></pre>\n<p><strong><code>biome.json</code></strong></p>\n<pre><code class=\"language-json\">{\n &quot;$schema&quot;: &quot;https://biomejs.dev/schemas/2.3.10/schema.json&quot;,\n &quot;vcs&quot;: {\n  &quot;enabled&quot;: false,\n  &quot;clientKind&quot;: &quot;git&quot;,\n  &quot;useIgnoreFile&quot;: false\n },\n &quot;files&quot;: {\n  &quot;ignoreUnknown&quot;: false,\n  &quot;includes&quot;: [\n   &quot;src/**/*.js&quot;,\n   &quot;src/**/*.json&quot;,\n   &quot;src/**/*.ts&quot;,\n   &quot;./test/**/*.ts&quot;\n  ]\n },\n &quot;formatter&quot;: {\n  &quot;enabled&quot;: true,\n  &quot;indentStyle&quot;: &quot;space&quot;,\n  &quot;indentWidth&quot;: 2\n },\n &quot;linter&quot;: {\n  &quot;enabled&quot;: true,\n  &quot;rules&quot;: {\n   &quot;recommended&quot;: true\n  }\n },\n &quot;javascript&quot;: {\n  &quot;formatter&quot;: {\n   &quot;quoteStyle&quot;: &quot;double&quot;\n  }\n },\n &quot;json&quot;: {\n  &quot;formatter&quot;: {\n   &quot;enabled&quot;: true\n  }\n },\n &quot;assist&quot;: {\n  &quot;enabled&quot;: true,\n  &quot;actions&quot;: {\n   &quot;source&quot;: {\n    &quot;organizeImports&quot;: &quot;on&quot;\n   }\n  }\n }\n}\n</code></pre>\n<h3>Automation Scripts</h3>\n<p>Standardize the build and development lifecycle within package.json.</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;tsx --watch src/app.ts&quot;,\n    &quot;build&quot;: &quot;rimraf ./dist &amp;&amp; tsc&quot;,\n    &quot;start&quot;: &quot;npm run build &amp;&amp; node dist/app.js&quot;,\n    &quot;biome:lint&quot;: &quot;biome lint ./src&quot;,\n    &quot;biome:lint:fix&quot;: &quot;biome lint --write ./src&quot;,\n    &quot;biome:format&quot;: &quot;biome format ./src&quot;,\n    &quot;biome:format:fix&quot;: &quot;biome format --write ./src&quot;\n  }\n</code></pre>\n<h2>Step 3: Application Structure</h2>\n<p>I use a Feature-Based Layout. By grouping code into features/, we maintain encapsulation and ensure the project remains navigable as it scales.</p>\n<pre><code>src/\n├── app.ts               # Application entry point\n├── server.ts            # Core Express server implementation\n├── routes.ts            # Main application router\n│\n├── config/\n│   └── config.ts         # Environment variable configuration\n│\n└── features/\n    └── products/        # An example feature module\n        ├── products-controller.ts\n        └── products-routes.ts\n</code></pre>\n<h2>Step 4: Implementation</h2>\n<h3>Validated Configuration</h3>\n<p>First, define your <code>.env</code> file (and don&#39;t forget to include it in your <code>.gitignore</code>).</p>\n<p><strong><code>.env</code></strong></p>\n<pre><code>PORT=3000\nNODE_ENV=development\nDEBUG=true\n</code></pre>\n<p>Now, we centralize environment variables to prevent runtime failures.</p>\n<p><strong><code>src/config/config.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import * as dotenv from &quot;dotenv&quot;;\ndotenv.config();\n\ntype Parser&lt;T&gt; = (val: string) =&gt; T;\n\nfunction parseString(val: string): string {\n  if (!val || val.trim() === &quot;&quot;) {\n    throw new Error(&quot;Expected non-empty string&quot;);\n  }\n  return val;\n}\n\nfunction parseNumber(val: string): number {\n  if (!val || Number.isNaN(Number(val))) {\n    throw new Error(`Expected valid number, got &quot;${val}&quot;`);\n  }\n  return Number(val);\n}\n\nfunction parseBoolean(val: string): boolean {\n  if (val !== &quot;true&quot; &amp;&amp; val !== &quot;false&quot;) {\n    throw new Error(`Expected &quot;true&quot; or &quot;false&quot;, got &quot;${val}&quot;`);\n  }\n  return val === &quot;true&quot;;\n}\n\nfunction getEnv&lt;T&gt;(name: string, parser: Parser&lt;T&gt;, defaultValue?: T): T {\n  const raw = process.env[name];\n  if (raw === undefined) {\n    if (defaultValue !== undefined) return defaultValue;\n    throw new Error(`Missing required environment variable: ${name}`);\n  }\n  return parser(raw);\n}\n\nexport const config = {\n  app: {\n    port: getEnv(&quot;PORT&quot;, parseNumber, 3000),\n    env: getEnv(&quot;NODE_ENV&quot;, parseString, &quot;development&quot;),\n    debug: getEnv(&quot;DEBUG&quot;, parseBoolean, false),\n  }\n};\n</code></pre>\n<h3>The Server Class</h3>\n<p>Encapsulating Express in a class provides a predictable lifecycle and keeps the internal instance protected.</p>\n<p><strong><code>src/server.ts</code></strong></p>\n<pre><code class=\"language-typescript\">// src/server.ts\nimport express, { type Router } from &quot;express&quot;;\n\n// A type defining the properties required to initialize the server.\ntype ServerProps = {\n  port: number;\n  routes: Router;\n};\n\nexport class Server {\n  private app = express();\n  private readonly port: number;\n  private readonly routes: Router;\n\n  constructor(options: ServerProps) {\n    const { port, routes } = options;\n    this.port = port;\n    this.routes = routes;\n    this.configure();\n  }\n\n  getApp() {\n    return this.app;\n  }\n\n  // Configures the Express application with necessary middleware.\n  private configure() {\n    // Middleware to parse incoming JSON requests.\n    this.app.use(express.json());\n    // Middleware to parse URL-encoded data.\n    this.app.use(express.urlencoded({ extended: true }));\n    // Mount the application routes.\n    this.app.use(this.routes);\n  }\n\n  // Starts the server.\n  public start() {\n    return this.app.listen(this.port, () =&gt; {\n      console.log(`Server running on port ${this.port}`);\n    });\n  }\n}\n</code></pre>\n<h3>Feature Layer</h3>\n<p>Controllers use arrow functions to preserve <code>this</code> context without manual binding.</p>\n<p><strong><code>src/features/products/products-controller.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import type { Request, Response } from &quot;express&quot;;\n\nconst products = [\n  {\n    id: 1,\n    name: &#39;Laptop&#39;,\n    description: &#39;A high-performance laptop&#39;,\n    price: 1200.00\n  },\n  {\n    id: 2,\n    name: &#39;Smartphone&#39;,\n    description: &#39;A feature-rich smartphone&#39;,\n    price: 800.00\n  },\n];\n\n\nexport class ProductsController {\n\n  public getProducts = async (_: Request, res: Response) =&gt; {\n\n    res.status(200).json(products);\n  };\n\n  public addProduct = async (_: Request, __: Response) =&gt; {\n    throw new Error(&quot;Not implemented&quot;);\n  };\n}\n</code></pre>\n<p><strong><code>src/features/products/products-routes.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { Router } from &quot;express&quot;;\nimport { ProductsController } from &quot;./products-controller&quot;;\n\nexport const productsRoutes = (): Router =&gt; {\n  const router = Router();\n\n  const controller = new ProductsController();\n\n  router.get(\n    &quot;/&quot;,\n    controller.getProducts,\n  );\n\n  router.post(\n    &quot;/&quot;,\n    controller.addProduct,\n  );\n\n  return router;\n};\n</code></pre>\n<h2>Step 5. Bootstrapping</h2>\n<p>Aggregate feature routes and initialize the server.</p>\n<p><strong><code>src/routes.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { Router, type Request, type Response } from &quot;express&quot;;\nimport { productsRoutes } from &quot;./features/products/products-routes&quot;;\n\nexport const appRoutes = (): Router =&gt; {\n  const router = Router();\n\n  router.use(&quot;/api/products&quot;, productsRoutes());\n\n  router.get(&#39;/health&#39;,\n    (_: Request, res: Response) =&gt; {\n      res.json({\n        status: &#39;up&#39;,\n        timestamp: new Date().toISOString(),\n        uptime: process.uptime()\n      });\n    });\n\n  return router;\n};\n</code></pre>\n<p><strong><code>src/app.ts</code></strong></p>\n<pre><code class=\"language-typescript\">import { config } from &quot;./config/config&quot;;\nimport { appRoutes } from &quot;./routes&quot;;\nimport { Server } from &quot;./server&quot;;\n\nasync function main() {\n\n  const server = new Server({\n    port: config.app.port,\n    routes: appRoutes(),\n  });\n\n  server.start();\n}\n\nmain();\n</code></pre>\n<h2>Running Your Application</h2>\n<p>Start the development server with hot-reloading, run:</p>\n<pre><code class=\"language-bash\">npm run dev\n</code></pre>\n<p>Verify the setup by testing these endpoints:</p>\n<ul>\n<li><p><code>Health Check</code>: GET <code>http://localhost:3000/health</code></p>\n</li>\n<li><p><code>Get Products</code>: GET <code>http://localhost:3000/api/products</code></p>\n</li>\n<li><p><code>Add Product</code>: POST <code>http://localhost:3000/api/products</code></p>\n</li>\n</ul>\n<h2>Conclusion</h2>\n<p>Building a Node.js project in 2026 shouldn&#39;t feel like starting from scratch every time. By using a class-based server, type-safe config, and a feature-first layout, you’re setting up a foundation designed for professional scale.</p>\n<p>The foundation is solid. Now we can move forward with the implementation of Schema Validation and Global Error Handling to ensure our API remains resilient and predictable.</p>\n"
}