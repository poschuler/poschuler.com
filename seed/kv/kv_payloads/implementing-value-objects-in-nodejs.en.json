{
  "attributes": {
    "type": "post",
    "title": "Implementing Value Objects in Node.js",
    "description": "A practical guide to implementing Value Objects in TypeScript and Node.js to create more robust and expressive domain models, inspired by Domain-Driven Design principles.",
    "tags": [
      "nodejs",
      "typescript",
      "ddd",
      "architecture",
      "value-object"
    ],
    "publishedAt": "2025-11-02",
    "repository": "https://github.com/poschuler/nodejs-ddd-value-objects"
  },
  "html": "<h2>I. Introduction: The Primitive Obsession and Data Integrity</h2>\n<p>When we begin working with Domain-Driven Design (DDD), we usually define the properties of our Entities/Aggregates using primitive JavaScript/TypeScript types, such as string, number, or Date. This, in itself, is not an error.</p>\n<p>However, the exclusive reliance on primitive types to represent domain concepts leads us to a problem we call the &quot;Primitive Obsession&quot;.</p>\n<h3>Problems of Primitive Obsession</h3>\n<p>Relying solely on primitive types leads us to two fundamental problems:</p>\n<ol>\n<li><p>Poor Ubiquitous Language: If we define a property as <code>email: string</code>, the code doesn&#39;t express the true domain intent, and questions arise like, Is it validated? Is it normalized? The language often becomes ambiguous-</p>\n</li>\n<li><p>Violation of DRY (Don&#39;t Repeat Yourself): In many cases, the primitive obsession leaves the door open for validation, normalization, and business rules to become scattered and decentralized, going against the DRY principle.</p>\n</li>\n</ol>\n<p>Following the email example, if the format is validated in the Controller, then in the Application layer, and again in the Domain layer, we are violating the DRY principle, which leads to fragile and harder-to-maintain code.</p>\n<h3>The DDD Solution: Value Objects (VOs)</h3>\n<p>In DDD, we implement Value Objects to help solve these problems.</p>\n<p>A Value Object (VO) is a pattern that seeks to encapsulate the logic for the validation, creation, and manipulation of a specific field or a group of fields.</p>\n<p>The VO not only defines the structure of the data but also the business rules that govern it. If a valid <code>EmailAddress</code> cannot be created, the creation must fail immediately, forcing the subsequent layer to handle the error</p>\n<h2>II. The Three Pillars of a Value Object</h2>\n<p>A Value Object (VO) is only a VO if it complies with three fundamental rules. These rules act as the contract that guarantees data integrity within the Domain. If an object does not meet one of these rules, it is likely an Entity, not a Value Object.</p>\n<ol>\n<li><p><strong>Immutability.</strong></p>\n<p> Once a Value Object is created, <strong>its value cannot change</strong>. To &quot;change&quot; a VO, you must destroy the old one and create a new instance.</p>\n<p> For example:</p>\n<ul>\n<li><p>If we have an <code>EmailAddress</code> with the value &quot;<a href=\"mailto:user@domain.com\">user@domain.com</a>&quot;, there should be no way to change its value to &quot;<a href=\"mailto:new@domain.com\">new@domain.com</a>&quot; or any other value.</p>\n</li>\n<li><p>If we consider a VO like <code>Money</code> that has a value of $10 and we wanted to add $5 to it, the add(5) method does not modify the current instance; it returns a new <code>Money</code> instance with the updated amount.</p>\n</li>\n</ul>\n<p> Immutability is important because it eliminates unexpected side effects. For instance, if you pass a VO to a service, you have full certainty that the service will not modify it, guaranteeing the object&#39;s consistency.</p>\n</li>\n<li><p><strong>Equality by Value.</strong></p>\n<p> Unlike Entities (which are defined by a unique identifier), a Value Object is defined by the value of its components; a VO does not have a unique identifier.</p>\n<p> Two VOs are equal if all their properties are equal.</p>\n<ul>\n<li><p>If we have a Money object A with <code>{amount: 10, currency: USD}</code> and a Money object B with <code>{amount: 10, currency: USD}</code>, they are exactly the same Value Object, even if they are two different instances in memory.</p>\n</li>\n<li><p>Thinking of a real-world example: A $20 bill is equal to any other $20 bill. The value is the same; its serial number is irrelevant to its function.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>The Guarantee of an &quot;Always Valid&quot; Value</strong></p>\n<p> The Value Object holds the exclusive responsibility of validating its own business rules and normalizing its data during the creation process.</p>\n<ul>\n<li><p><strong>Validation</strong>: Does the <code>EmailAddress</code> comply with the required format? Does the <code>DateRange</code> have a start date that precedes the end date?</p>\n</li>\n<li><p><strong>Normalization</strong>: If the input is &quot;<a href=\"mailto:USER@DOMAIN.COM\">USER@DOMAIN.COM</a>&quot;, the VO will internally convert it to its canonical form (clean and lowercase): &quot;<a href=\"mailto:user@domain.com\">user@domain.com</a>&quot;.</p>\n</li>\n</ul>\n<p> If validation fails or normalization is impossible, the VO will prevent its own creation, either by throwing an exception or by returning a Result object containing the error. This ensures that only valid objects enter our Domain</p>\n</li>\n</ol>\n<h2>III. Building the Base <code>ValueObject</code> Class</h2>\n<p>The goal is to create an abstract base class, <code>ValueObject</code>, which handles <strong>equality by value</strong> and defines the contract of immutability for all classes that inherit from it.</p>\n<p>A. The Abstract <code>ValueObject</code></p>\n<pre><code class=\"language-typescript\">// Define EqualityComponent to handle both primitives and nested VOs for value equality\ntype EqualityComponent = string | number | boolean  | Date | null | undefined | ValueObject;\n\nexport abstract class ValueObject {\n\n  /**\n  * Equality Contract:\n  * Obliges every VO to declare which properties define its value.\n  * @returns An array of the components that must be compared.\n  */\n  protected abstract getEqualityComponents(): EqualityComponent[];\n\n  /**\n  * Method to compare two VOs.\n  */\n  public equals(other?: ValueObject): boolean {\n    // 1. Check if the object to compare is null or undefined\n    if (other === null || other === undefined) {\n      return false;\n    }\n\n    // 2. Check if they are of the same type\n    if (other.constructor !== this.constructor) {\n      return false;\n    }\n\n    // 3. Get the components to compare\n    const componentsA = this.getEqualityComponents();\n    const componentsB = other.getEqualityComponents();\n\n    // 4. Check that they have the same length\n    if (componentsA.length !== componentsB.length) {\n      return false;\n    }\n\n    // 5. Iterate the components and compare them\n    return componentsA.every((component, index) =&gt; {\n      const otherComponent = componentsB[index];\n\n      // 6. If any of the components is null or undefined\n      if (component === null || component === undefined || otherComponent === null || otherComponent === undefined) {\n        return component === otherComponent;\n      }\n\n      // 7. If any of the components is a ValueObject, compare recursively\n      if (component instanceof ValueObject &amp;&amp; otherComponent instanceof ValueObject) {\n        return component.equals(otherComponent);\n      }\n\n      // 8. If they are of type Date\n      if (component instanceof Date &amp;&amp; otherComponent instanceof Date) {\n        return component.getTime() === otherComponent.getTime();\n      }\n\n      // 9. Otherwise, compare the primitive values\n      return component === otherComponent;\n    });\n  }\n}\n</code></pre>\n<p>B. Immutability and Extensibility</p>\n<p>With this <em>abstract base class</em>, we achieve two critical things</p>\n<ol>\n<li><p><strong>Contract Enforcement</strong>: By making <code>getEqualityComponents()</code> abstract, we force every developer creating a new VO to explicitly declare what defines its value. There is no way to forget this.</p>\n</li>\n<li><p><strong>Automatic Equality</strong>: The <code>equals()</code> method does all the heavy lifting, including recursive comparison for nested VOs.</p>\n<ul>\n<li>For example, if we compare two <code>Money</code> objects, the <code>equals</code> method knows that the <code>Currency</code> component is, in turn, another <code>ValueObject</code>, and automatically calls <code>currency.equals()</code> to ensure a deep and correct comparison.</li>\n</ul>\n</li>\n</ol>\n<h2>IV. Real-World Examples of Value Objects</h2>\n<p>A. Example 1: <code>EmailAddress</code></p>\n<p>For this example, the VO will ensure that the internal string is always a valid and canonical email. For this, we will use:</p>\n<ol>\n<li><p><code>static create()</code>: This static method will be the sole responsible for creating a new VO, performing validation and normalization</p>\n</li>\n<li><p><code>private constructor()</code>: We define a private constructor, thereby only allowing objects to be created from the <code>create()</code> method.</p>\n</li>\n</ol>\n<pre><code class=\"language-typescript\">\nexport class Email extends ValueObject {\n\n  //Immutable state (readonly)\n  public readonly value: string;\n\n  //Private constructor\n  private constructor(value: string) {\n    super();\n    this.value = value;\n  }\n\n  //Static factory, receives the input, validates and normalizes the email, in case of error it should throw an exception.\n  public static create(input: string): Email {\n\n    if (!input) throw new Error(&quot;Email requires a value&quot;);\n\n    const normalizedEmail = input.trim().toLowerCase();\n\n    if (!Email.isValid(normalizedEmail)) {\n      throw new Error(&quot;Invalid email address&quot;);\n    }\n\n    return new Email(normalizedEmail);\n  }\n\n  // Method that returns the components to compare\n  protected getEqualityComponents() {\n    return [this.value];\n  }\n\n  // Simple logic to validate an email\n  private static isValid(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n}\n</code></pre>\n<p>With this implementation, we ensure that any <code>Email</code> instance is always a valid instance.</p>\n<p>Likewise, we can validate the equality functionality of our class with a simple example.</p>\n<pre><code class=\"language-typescript\">\n// 1. Creating two different instances in memory\nconst emailA = Email.create(&quot;ADMIN@company.com&quot;);\nconst emailB = Email.create(&quot;admin@company.com&quot;);\n\n// 2. Comparing memory references (should be false)2. Comparing memory references\nconsole.log(`emailA === emailB: ${emailA === emailB}`); // -&gt; false\n\n// 3. Comparing by Value (should be true)\nconsole.log(`emailA.equals(emailB): ${emailA.equals(emailB)}`); // -&gt; true\n\n// 4. A case of inequality\nconst emailC = Email.create(&quot;anotherAdmin@company.com&quot;);\nconsole.log(`emailA.equals(emailC): ${emailA.equals(emailC)}`); // -&gt; false\n</code></pre>\n<p>  <img src=\"https://raw.githubusercontent.com/poschuler/nodejs-ddd-value-objects/refs/heads/main/architecture/diagrams/Email-Value-Object.svg\" alt=\"Email Value Object\"></p>\n<p>B. Example 2: <code>Money</code></p>\n<p>The Money VO is more complex because it is composed of amount and currency, both of which are Value Objects.</p>\n<p>First, we define Amount, for which we will use BigNumber to avoid problems with decimal values.</p>\n<pre><code class=\"language-typescript\">import BigNumber from &quot;bignumber.js&quot;;\n\nconst ROUNDING_MODE = BigNumber.ROUND_HALF_UP;\nconst DECIMAL_PLACES = 2;\n\ntype AmountProps = {\n  readonly value: BigNumber;\n};\n\nexport class Amount extends ValueObject {\n\n  public readonly value: BigNumber;\n\n  private constructor(props: AmountProps) {\n    super();\n    this.value = props.value.dp(DECIMAL_PLACES, ROUNDING_MODE);\n  }\n\n  public static create(input: number | string | BigNumber): Amount {\n    try {\n      const bigValue = new BigNumber(input);\n\n      if (bigValue.isNaN()) {\n        throw new Error(&quot;Invalid amount: not a number&quot;);\n      }\n\n      if (bigValue.isNegative()) {\n        throw new Error(&quot;Invalid amount: amount cannot be negative&quot;);\n      }\n\n      return new Amount({ value: bigValue });\n    } catch {\n      throw new Error(`Error creating Amount from input: ${input}`);\n    }\n  }\n\n  public add(other: Amount): Amount {\n    const newValue = this.value.plus(other.value);\n    return new Amount({ value: newValue });\n  }\n\n  public times(multiplier: number): Amount {\n    const newValue = this.value.times(multiplier);\n    return new Amount({ value: newValue });\n  }\n\n  public isZero(): boolean {\n    return this.value.isZero();\n  }\n\n  public toString(): string {\n    return this.value.toFixed(DECIMAL_PLACES, ROUNDING_MODE);\n  }\n\n  public toNumber(): number {\n    return parseFloat(this.toString());\n  }\n\n  protected getEqualityComponents() {\n    return [this.value.toFixed(DECIMAL_PLACES)];\n  }\n}\n</code></pre>\n<p>Now we define Money, which will utilize Amount.</p>\n<pre><code class=\"language-typescript\">\ntype MoneyProps = {\n  readonly amount: number;\n  readonly currency: Currency;\n};\n\ntype CreateMoneyProps = {\n  readonly amount: number | string;\n  readonly currency: Currency;\n};\n\nexport class Money extends ValueObject {\n\n  //Nested Amount VO\n  public readonly amount: Amount;\n\n  //Nested Currency VO\n  public readonly currency: Currency;\n\n  private constructor(props: MoneyProps) {\n    super();\n    this.amount = props.amount;\n    this.currency = props.currency;\n  }\n\n  // Static factory with validation\n  static create(inputProps: CreateMoneyProps) {\n    if (!inputProps) throw new Error(&quot;Money requires props&quot;);\n    if (!inputProps.currency) throw new Error(&quot;Money requires currency&quot;);\n\n    const amountVO = Amount.create(inputProps.amount);\n\n    return new Money({\n      amount: amountVO,\n      currency: inputProps.currency,\n    });\n  }\n\n  //The add method does not modify the VO; instead, it returns a new instance\n  public add(other: Money): Money {\n    if (!this.currency.equals(other.currency)) {\n      throw new Error(&quot;Cannot add money with different currencies&quot;);\n    }\n\n    const newAmount = this.amount.add(other.amount);\n\n    return new Money({\n      amount: newAmount,\n      currency: this.currency,\n    });\n  }\n\n  //Other methods we can use in our domain, depending on the case\n  public static zero(): Money;\n  public static zero(props: { currency: Currency }): Money;\n\n  public static zero(props?: { currency: Currency }): Money {\n    const currency = props?.currency ?? Currency.None;\n    const zeroAmount = Amount.create(0);\n    return new Money({ currency, amount: zeroAmount });\n  }\n\n  public isZero(): boolean {\n    return this.amount.isZero();\n  }\n\n  public isZeroInCurrency({ currency }: { currency: Currency }): boolean {\n    return this.amount.isZero() &amp;&amp; this.currency.equals(currency);\n  }\n\n  // Method that returns the components to compare, including the nested VO\n  protected getEqualityComponents() {\n    return [this.amount, this.currency]\n  }\n  \n}\n</code></pre>\n<ul>\n<li><p>Composition: We can compose two VOs by nesting them as needed; in our example, we used Currency and Amount inside Money.</p>\n</li>\n<li><p>Immutability: The <code>add()</code> method always creates and returns a <code>new Amount()</code>, never modifying its own state.</p>\n<p><img src=\"https://raw.githubusercontent.com/poschuler/nodejs-ddd-value-objects/refs/heads/main/architecture/diagrams/Money-Value-Object.svg\" alt=\"Money Value Object\"></p>\n</li>\n</ul>\n<h2>V. Final Thoughts</h2>\n<ul>\n<li><p>The Primitive Obsession can lead us to write code that is expensive to maintain and fragile</p>\n</li>\n<li><p>The use of Value Objects is a pragmatic design decision that improves the ubiquitous language of the domain.</p>\n</li>\n<li><p>Using Value Objects helps us ensure that the domain always has valid and consistent data.</p>\n</li>\n<li><p>Value Objects are the foundation for building an expressive and robust Domain.</p>\n</li>\n</ul>\n<p>Value Objects are a simple and powerful solution, helping us encapsulate validation and value logic within immutable objects.</p>\n"
}